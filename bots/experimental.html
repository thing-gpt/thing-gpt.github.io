<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Thing-GPT</title>
  <link rel="stylesheet" href="/styles/theme.css">
  <meta name="google-adsense-account" content="ca-pub-6553820111354942">
  <style>
    .hidden-thought {
      display: none;
    }
    #sendBtn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
            .toolbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            background-color: rgba(207, 207, 207, 0.692);
            position: fixed;
            top: 0;
            left: 0;
            width: 10%;
            height: 100%;
        } 

          .toolbar-header {
            display: flex;
            margin-top: 30px;

          }
            .send-section {
            display: flex;
            margin-top: 30px;
            flex-direction: row;
            width: 100%;

          }
  </style>
</head>
<body>

  <div class="chat-container">
    <div id="chatWindow"></div>
      <div class="send-section">
      <input type="text" id="myText" placeholder="Type a message...">
      <button id="sendBtn" disabled> Send</button>
      <button id="clearBtn" class="clear-btn">Clear Chat</button>
      </div>
  </div>

  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6553820111354942"
     crossorigin="anonymous"></script>
  <script type="module">
  import Groq from "https://esm.sh/groq-sdk";
  import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm";

  const supabaseUrl = "https://qcdmvyhxhkwkvmrvtfhd.supabase.co";
  const supabaseKey = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFjZG12eWh4aGt3a3ZtcnZ0ZmhkIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc0NDI0MjQ2OCwiZXhwIjoyMDU5ODE4NDY4fQ.4KLPIJqE_TsNVnM5-sdBaaVOQHYQJNkMfwcB17_1zzQ";
  const supabaseClient = createClient(supabaseUrl, supabaseKey);
  const chatWindow = document.getElementById("chatWindow");
  const inputField = document.getElementById("myText");
  const sendBtn = document.getElementById("sendBtn");
  const clearBtn = document.getElementById("clearBtn");


  // Array of URLs, each providing a single API key
  const apiKeyUrls = [
    'https://thinggptapi.vercel.app/plaintext.js',
    'https://thinggptapi.vercel.app/plaintext2.js',
    'https://thinggptapi.vercel.app/plaintext3.js'
    // Add more URLs as needed
  ];
  let currentUrlIndex = 0; // Track the current URL index

  async function fetchApiKey(url) {
    try {
      const res = await fetch(url, {
        cache: 'no-store',
        method: 'GET',
      });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const key = (await res.text()).trim();
      console.log(`API key loaded from ${url}`);
      return key;
    } catch (err) {
      console.error(`Could not load API key from ${url}:`, err);
      return null;
    }
  }

  // Function to get the next API key by cycling through URLs
  async function getNextApiKey() {
    if (apiKeyUrls.length === 0) return null;
    const url = apiKeyUrls[currentUrlIndex];
    currentUrlIndex = (currentUrlIndex + 1) % apiKeyUrls.length; // Cycle to the next URL
    console.log(`Fetching API key from: ${url}`);
    const key = await fetchApiKey(url);
    return key;
  }

  // Initial check to enable send button
  document.addEventListener('DOMContentLoaded', async () => {
    // Test the first URL to ensure at least one key is accessible
    const initialKey = await fetchApiKey(apiKeyUrls[0]);
    if (initialKey) {
      sendBtn.disabled = false; // Enable send button if a key is accessible
    } else {
      addMessage("system", "Error: Failed to load API key from initial URL. Please try refreshing the page.");
    }

    let conversationHistory = JSON.parse(localStorage.getItem("chatHistorySG")) || [];
    let aiPrompt = localStorage.getItem("aiPrompt") || "";
    renderHistory(conversationHistory);

    inputField.addEventListener("keydown", (event) => {
      if (event.key === "Enter" && !event.shiftKey) {
        event.preventDefault();
        sendBtn.click();
      }
    });

    sendBtn.addEventListener("click", async () => {
      const userText = inputField.value.trim();
      if (!userText) return;

      const apiKey = await getNextApiKey();
      if (!apiKey) {
        addMessage("system", "Error: No API key available. Please try again later.");
        return;
      }

      addMessage("user", userText);
      inputField.value = "";

      const groq = new Groq({ apiKey, dangerouslyAllowBrowser: true });
      try {
        const messages = [
          {
            role: "system",
            content:
              ""
          },
          ...conversationHistory,
          { role: "user", content: userText },
        ];

        const result = await groq.chat.completions.create({
          messages: messages,
          model: "llama-3.3-70b-versatile",
        });

        const aiResponse = result.choices[0]?.message?.content || "No response.";
        addMessage("assistant", aiResponse);
        if (document.visibilityState === "visible") {
        document.title = "Thing-GPT";
        } else {
        document.title = "Saul has Responded!";
        ding.play();
        }
      } catch (err) {
        console.error(err);
        addMessage("assistant", "[Error getting response, please try again.]");
      }
    });

    clearBtn.addEventListener("click", () => {
      localStorage.removeItem("chatHistorySG");
      localStorage.removeItem("aiPrompt");
      conversationHistory = [];
      aiPrompt = "";
      chatWindow.innerHTML = "";
      saul.src = moodImages['#default']; // Reset to default image on clear
    });

    async function addMessage(role, content) {
      const msg = { role, content };
      conversationHistory.push(msg);
      console.log(`Adding message - Role: ${role}, Content: ${content}`);
      localStorage.setItem("chatHistorySG", JSON.stringify(conversationHistory));
      chatWindow.appendChild(createMessageBubble(msg));
      chatWindow.scrollTop = chatWindow.scrollHeight;
      try {
        const { error } = await supabaseClient.from("chat_logs").insert([{ role, content }]);
        if (error) {
          console.error("Failed to log message to Supabase:", error);
        }
      } catch (err) {
        console.error("Error inserting into Supabase:", err);
      }
    }


    function renderHistory(history) {
      history.forEach((msg) => {
        chatWindow.appendChild(createMessageBubble(msg));
      });
      chatWindow.scrollTop = chatWindow.scrollHeight;
    }

    function createMessageBubble({ role, content }) {
      const div = document.createElement("div");
      div.className = role === "user" ? "user-bubble" : "ai-bubble";

      let processedContent = content;
      let moodSet = false;

      if (role === "assistant") {
        console.log(`Raw AI response: ${content}`);
        const moodMatch = content.match(/^#(happy|mad|serious|sad|calling)\b\s*/i);
        if (moodMatch) {
          const mood = `#${moodMatch[1].toLowerCase()}`;
          console.log(`Detected mood: ${mood}`);
          if (moodImages[mood]) {
            saul.src = moodImages[mood];
            moodSet = true;
          }
          processedContent = content.slice(moodMatch[0].length);
        } else {
          console.log('No mood detected at start');
        }

        if (!moodSet) {
          saul.src = moodImages['#default'];
        }

        processedContent = processedContent.replace(/\*([^*]+)\*/g, "<em>$1</em>");
        processedContent = processedContent.replace(/:trol:/g, '<img src="/img/trollface.png" alt="troll" class="chat-emoji" width="24" height="24">');
      } else {
        processedContent = content.replace(/\*([^*]+)\*/g, "<em>$1</em>");
        processedContent = processedContent.replace(/:trol:/g, '<img src="/img/trollface.png" alt="troll" class="chat-emoji" width="24" height="24">');
      }

      div.innerHTML = processedContent.trim();
      return div;
    }
  });
</script>
</body>
</html>